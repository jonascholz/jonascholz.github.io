---
title: 'The adaptive LIF (adLIF) neuron (WIP)'
date: 2025-06-28
permalink: /posts/2025/06/ad-lif/
tags:
  - adLIF
  - Tutorial
  - SNN
  - JAX
---

WIP, come back later

A model based on the adaptive LIF (adLIF) neuron achieved 95.8% accuracy on the Spiking Heidelberg Digits (SHD) dataset in 2024. How does it do that? Let's get some insight from the dudes who did it: Baronig et al. ([link to paper](https://arxiv.org/abs/2408.07517)).

## How it works
At its core, the adLIF is just a LIF with an additional term. You could call it a generalization. Let's look at the discrete definition of its membrane voltage $$\textcolor{green}{\hat{u}[t]}$$ and then figure out that additional term.

$$
\begin{equation}
\textcolor{green}{\hat{u}[t]} = \textcolor{blue}{\alpha} \textcolor{ForestGreen}{u[t-1]} + (1-\textcolor{blue}{\alpha})(-\textcolor{red}{w[t-1]} + \textcolor{purple}{I[t]}) \\
\label{eq:u_hat}
\end{equation}
$$

where $$\textcolor{ForestGreen}{u[t-1]}$$ is the neuron's membrane potential at step t-1. $$\textcolor{blue}{\alpha}$$ is the membrane potential decay rate (TODO crossreference the version from eshraghian and figure out why he doesnt have (1-alpha)). The additional term $$\textcolor{red}{w[t-1]}$$ makes the neuron resonate and adapt, which I'll explain soon. Finally, $$\textcolor{purple}{I[t]}$$ is the input current at step t.

Note that we distinguish between $$\textcolor{green}{\hat{u}[t]}$$ and $$\textcolor{ForestGreen}{u[t]}$$. The first one, $$\textcolor{green}{\hat{u}[t]}$$, is the pre-activation. We use it to check if the membrane potential passes the threshold and potentially reset the membrane potential. $$\textcolor{ForestGreen}{u[t]}$$ is the actual state that we carry to the next timestep. You can check this for yourself in the original implementation [here](https://github.com/IGITUGraz/SE-adlif/blob/main/models/alif.py). The reset equation is shown below.

$$
\begin{equation}
\textcolor{ForestGreen}{u[t]} = \textcolor{green}{\hat{u}[t]} (1 - \textcolor{orange}{S[t]}) + \textcolor{brown}{u_{rest}}\textcolor{orange}{S[t]}
\label{eq:u_reset}
\end{equation}
$$

where $$\textcolor{brown}{u_{rest}}$$ is the resting potential and $$\textcolor{orange}{S[t]}$$ is the spike output at time t (1 if spike, 0 otherwise). Okay now for the main part. What is this additional term $$\textcolor{red}{w[t-1]}$$? 

$$
\begin{equation}
\textcolor{red}{w[t]} = \textcolor{blue}{\beta} \textcolor{red}{w[t-1]} + (1-\textcolor{blue}{\beta})(\textcolor{olive}{a}\textcolor{ForestGreen}{u[t]} + \textcolor{magenta}{b}\textcolor{orange}{S[t]})
\label{eq:w}
\end{equation}
$$

We will go through those step by step, but for completeness: $$\textcolor{blue}{\beta}$$ is another decay term, this time for the adaptive component. $$\textcolor{olive}{a}$$ and $$\textcolor{magenta}{b}$$ are constants that control the sub-threshold and spike-triggered adaptation, respectively.

Let's just say the decay $$\textcolor{blue}{\beta} = 0.98$$ and thus $$1 - \textcolor{blue}{\beta} = 0.02$$. We will also ignore the spike-triggered adaptation for now and set $$\textcolor{olive}{a} = 20$$. In this case, the equation simplified to

$$
\begin{equation}
\begin{split}
\textcolor{red}{w[t]} &= \textcolor{blue}{0.98} \textcolor{red}{w[t-1]} + \textcolor{blue}{0.02}(\textcolor{olive}{20}\textcolor{ForestGreen}{u[t]})\\
&= \textcolor{blue}{0.98} \textcolor{red}{w[t-1]} + \textcolor{olive}{0.4}\textcolor{ForestGreen}{u[t]}
\end{split}
\label{eq:w_simple}
\end{equation}
$$

Okay now this part looks more manageable. So we start with a LIF and at every step t we subtract $$\textcolor{red}{w[t-1]}$$. The term is then updated by decaying it and adding some scaled down version of the membrane potential. We can see what happens for different starting values $$\textcolor{ForestGreen}{u[0]}$$ in the plot below. 

<div style="display: flex; flex-direction: row; align-items: center; justify-content: center; width: 100%;">
    <div style="display: flex; flex-direction: column; align-items: center; width: 10%;">
        <label for="u0_slider" style="margin-bottom: 10px; color: #2ca02c; font-weight: bold;">u[0]</label>
        <input type="range" min="0" max="1" value="0.5" step="0.05" id="u0_slider" style="writing-mode: vertical-lr; direction: rtl; box-shadow:none;">
        <p><span id="u0_value">0.50</span></p>
    </div>
    <div id="plot" style="width: 90%; height: 400px;"></div>
</div>

<script src="https://cdn.plot.ly/plotly-2.20.0.min.js"></script>
<script src="{{ '/assets/js/adlif.js' | relative_url }}"></script>
<script>
{% raw %}
    document.addEventListener('DOMContentLoaded', function() {
        const u0_slider = document.getElementById('u0_slider');
        const u0_value_span = document.getElementById('u0_value');

        function update_plot() {
            const u0 = parseFloat(u0_slider.value);
            u0_value_span.textContent = u0.toFixed(2);

            const { u, w, s } = run_adlif_simulation({ u0 });
            const time = Array.from({ length: 200 }, (_, i) => i);

            const trace1 = {
                x: time,
                y: u,
                mode: 'lines',
                name: 'u(t) (Membrane Potential)',
                line: {color: '#2ca02c'}
            };

            const trace2 = {
                x: time,
                y: w,
                mode: 'lines',
                name: 'w(t) (Adaptive Current)',
                line: {color: '#d62728', dash: 'dash'},
            };
            
            const spike_times = time.filter((t, i) => s[i] === 1);
            const spike_heights = spike_times.map(() => 1.5); 

            const trace3 = {
                x: spike_times,
                y: spike_heights,
                mode: 'markers',
                name: 'Spikes S(t)',
                marker: { symbol: 'triangle-up', color: '#ff7f0e', size: 10 }
            };


            const layout = {
                title: 'AdLIF Neuron Dynamics',
                xaxis: { title: 'Time (steps)' },
                yaxis: { title: 'Value', range: [-0.5, 1.5] },
                legend: { x: 0.7, y: 0.95 }
            };

            Plotly.react('plot', [trace2, trace1, trace3], layout);
        }

        u0_slider.addEventListener('input', update_plot);

        // Initial plot
        update_plot();
    });
{% endraw %}
</script>


This was the SE adLif. Other implementations may use euler-forward version, which is very similar but TODO as shown in the paper ([still the same paper](https://arxiv.org/abs/2408.07517)).

## Why it works
WIP