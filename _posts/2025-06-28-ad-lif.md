---
title: 'The adaptive LIF (adLIF) Neuron (WIP)'
date: 2025-06-28
permalink: /posts/2025/06/ad-lif/
tags:
  - adLIF
  - Tutorial
  - SNN
  - JAX
---

The adaptive LIF (adLIF) neuron has been showing some great results on Spiking Heidelberg Digits (SHD) dataset and TODO where else? It is a generalization of the LIF neuron with some resonance dynamics. This article goes over its basic function and sketches an implementation. For a full JAX implementation, please refer to TODO link to repo.



<div class="lif-simulation">
  <h3>Reminder: LIF dynamics</h3>
  <p>As we recall the LIF neuron simply increases its membrane potential with incoming spikes or current. This membrane potential decays over time, unless a threshold is reached, in which case it resets to a baseline value and emits a spike. </p>
  <p>Click in the "Input Spikes" area add spikes.</p>
  
  <div style="display: grid; grid-template-columns: 1fr; gap: 1rem; max-width: 600px; margin: auto;">
  <div style="text-align: right;">
    <button id="reset-btn">Clear</button>
  </div>
    <div>
      <strong>Input Spikes (Click to add)</strong>
      <div id="input-spikes-container" style="border: 1px solid #ccc; height: 50px; position: relative; background-color: #f9f9f9; cursor: pointer;"></div>
    </div>
    
    <div>
      <strong>Membrane Potential (V<sub>m</sub>)</strong>
      <canvas id="membrane-potential-canvas" width="600" height="200" style="border: 1px solid #ccc; background-color: #fff;"></canvas>
    </div>

    <div>
      <strong>Output Spikes</strong>
      <div id="output-spikes-container" style="border: 1px solid #ccc; height: 50px; position: relative; background-color: #f9f9f9;"></div>
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const inputContainer = document.getElementById('input-spikes-container');
    const canvas = document.getElementById('membrane-potential-canvas');
    const outputContainer = document.getElementById('output-spikes-container');
    const ctx = canvas.getContext('2d');
    const resetBtn = document.getElementById('reset-btn');

    // LIF Neuron Parameters
    const v_thresh = 1.0;
    const v_reset = 0.0;
    const tau_mem = 20; // ms
    const dt = 0.5; // ms, simulation time step
    const membrane_decay = Math.exp(-dt / tau_mem);
    const input_current_injection = 0.5;

    // Simulation state
    let v_mem = 0.0;
    const history_size = canvas.width;
    let v_mem_history = new Array(history_size).fill(0);
    let input_currents = new Array(history_size).fill(0);

    function addSpike(container, position) {
        const spikeEl = document.createElement('div');
        spikeEl.style.position = 'absolute';
        spikeEl.style.left = `${position}px`;
        spikeEl.style.top = '0';
        spikeEl.style.width = '2px';
        spikeEl.style.height = '100%';
        spikeEl.style.backgroundColor = 'black';
        container.appendChild(spikeEl);
    }

    function setDefaultSpikes() {
        inputContainer.innerHTML = '';
        input_currents = new Array(history_size).fill(0);

        // Spike at ~20%
        const spike1_t = Math.floor(history_size * 0.20);
        input_currents[spike1_t] = input_current_injection;
        addSpike(inputContainer, spike1_t);

        // Two spikes at ~60%
        const spike2_t = Math.floor(history_size * 0.60);
        const spike3_t = spike2_t + 15;
        input_currents[spike2_t] = input_current_injection;
        addSpike(inputContainer, spike2_t);
        input_currents[spike3_t] = input_current_injection;
        addSpike(inputContainer, spike3_t);
    }

    inputContainer.addEventListener('click', (event) => {
        const rect = inputContainer.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const time_step = Math.floor(x);
        if(time_step >= 0 && time_step < history_size) {
            input_currents[time_step] = input_current_injection;
            addSpike(inputContainer, x);
        }
    });

    resetBtn.addEventListener('click', () => {
        input_currents = new Array(history_size).fill(0);
        inputContainer.innerHTML = '';
    });

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw threshold line
        ctx.beginPath();
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        const thresholdY = canvas.height * (1 - v_thresh / 1.5);
        ctx.moveTo(0, thresholdY);
        ctx.lineTo(canvas.width, thresholdY);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Draw membrane potential
        ctx.beginPath();
        ctx.strokeStyle = 'blue';
        ctx.lineWidth = 2;
        ctx.moveTo(0, canvas.height * (1 - v_mem_history[0] / 1.5));
        for (let i = 1; i < history_size; i++) {
            const y = canvas.height * (1 - v_mem_history[i] / 1.5);
            ctx.lineTo(i, y);
        }
        ctx.stroke();
    }

    function update() {
        v_mem = 0; // Reset for full simulation run
        v_mem_history = new Array(history_size).fill(0);
        outputContainer.innerHTML = '';

        for (let t = 0; t < history_size; t++) {
            v_mem = v_mem * membrane_decay + input_currents[t];

            if (v_mem >= v_thresh) {
                v_mem = v_reset;
                addSpike(outputContainer, t);
            }
            v_mem_history[t] = v_mem;
        }

        draw();
        requestAnimationFrame(update);
    }

    setDefaultSpikes();
    update();
});
</script>

